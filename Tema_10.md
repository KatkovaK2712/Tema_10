# Тема 10. Декораторы и исключения
Отчет по Теме #10 выполнил(а):
- Каткова Ксения Александровна
- ПИЭ-22-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
Наверняка вы думаете, что декораторы – это какая-то бесполезная вещь, которая вам никогда не пригодится, но тут вдруг на паре по математике преподаватель просит всех посчитать число Фибоначчи для 100. Кто-то будет считать вручную (так точно не нужно), кто-то посчитает на калькуляторе, а кто-то подумает, что он самый крутой и напишет рекурсивную программу на Python и немного огорчится, потому что данная программа будет достаточно долго считаться, если ее просто так запускать. Но именно тут к вам на помощь приходят декораторы, например @lru_cache (он предназначен для решения задач динамическим программированием, если простыми словами, то этот декоратор запоминает промежуточные результаты и при рекурсивном вызове функции программа не будет считать одни и те же значения, а просто “возьмёт их из этого декоратора”). Вам нужно написать программу, которая будет считать числа Фибоначчи для 100 и запустить ее без этого декоратора и с ним, посмотреть на разницу во времени решения поставленной задачи.
P.S. при запуске без декоратора можете долго не ждать, для наглядности хватит 10 секунд ожидания.

```python
import time
from functools import lru_cache
@lru_cache(maxsize=None)
def fibonacci(n):
    if n <= 1:
        return n
    else:
        return fibonacci(n-1) + fibonacci(n-2)
@lru_cache(maxsize=None)
def fibonacci_cached(n):
    if n <= 1:
        return n
    else:
        return fibonacci_cached(n-1) + fibonacci_cached(n-2)
start_time = time.time()
print(f"Непосредственное вычисление F(100): {fibonacci(100)}")
print(f"Время выполнения без декоратора: {time.time() - start_time} секунд")
start_time = time.time()
print(f"Вычисление с кэшем F(100): {fibonacci_cached(100)}")
print(f"Время выполнения с декоратором: {time.time() - start_time} секунд")
```
### Результат.
![image](https://github.com/user-attachments/assets/3e875820-b71c-427e-a872-1a7c8d128eb8)

## Выводы
Кэширование результатов предыдущих вычислений с помощью декоратора @lru_cache может значительно повысить производительность рекурсивных функций.

## Лабораторная работа №2
Илья пишет свой сайт и ему необходимо сделать минимальную проверку ввода данных пользователя при регистрации. Для этого он реализовал функцию, которая выводит данные пользователя на экран и решил, что будет проверять правильность введённых данных при помощи декоратора, но в этом ему потребовалась ваша помощь. Напишите декоратор для функции, который будет принимать все параметры вызываемой функции (имя, возраст) и проверять чтобы возраст был больше 0 и меньше 130. 
Причем заметьте, что неважно сколько пользователь введет данных на сайт к Илье, будут обрабатываться только первые 2 аргумента. 

```python
def age_check_decorator(func):
    def wrapper(name, age, *args, **kwargs):
        if not (0 < age < 130):
            raise ValueError("Возраст должен быть больше 0 и меньше 130.")
        return func(name, age, *args, **kwargs)
    return wrapper
@age_check_decorator
def register_user(name, age):
    print(f"Имя: {name}, Возраст: {age}")
try:
    register_user("Илья", 25)
    register_user("Илья", 150)
except ValueError as ve:
    print(ve)
```
### Результат.
![image](https://github.com/user-attachments/assets/f0b8c34f-4ff7-4951-9eb7-0f8053e97ced)

## Выводы
- Код использует декоратор для проверки возраста пользователя.
- Если возраст не соответствует заданным условиям, будет выброшено исключение ValueError.
- Исключение обрабатывается с помощью блока try-except.

## Лабораторная работа №3
Вам понравилась идея Ильи с сайтом, и вы решили дальше работать вместе с ним. Но вот в вашем проекте появилась проблема, кто-то пытается сломать вашу функцию с получением данных для сайта. Эта функция работает только с данными integer, а какой-то недохакер пытается все сломать и вместо нужного типа данных отправляет string. 
  
Воспользуйтесь исключениями, чтобы неподходящий тип данных не ломал ваш сайт. 
Также дополнительно можете обернуть весь код функции в try/except/finally для того, чтобы программа вас оповестила о том, что выявлена какая-то ошибка или программа успешно выполнена. 

```python
def user_data_input(name, age):
    try:
        if not isinstance(age, int):
            raise TypeError("Возраст должен быть целым числом.")
        print(f"Имя: {name}, Возраст: {age}")
    except TypeError as te:
        print(te)
    finally:
        print("Функция завершила выполнение.")
user_data_input("Илья", "двадцать пять")
user_data_input("Илья", 25)
```
### Результат.
![image](https://github.com/user-attachments/assets/81302122-244b-4319-9971-d6ba28701c32)

## Выводы
Функция user_data_input() проверяет, что возраст является целым числом, и в случае ошибки выводит сообщение об ошибке, а в конце всегда выводит сообщение о завершении функции.

## Лабораторная работа №4
 Продолжая работу над сайтом, вы решили написать собственное исключение, которое будет вызываться в случае, если в функцию проверки имени при регистрации передана строка длиннее десяти символов, а если имя имеет допустимую длину, то в консоль выводиться “Успешная регистрация” 

```python
class NameTooLongError(Exception):
    pass
def check_name_length(name):
    if len(name) > 10:
        raise NameTooLongError("Имя не должно превышать 10 символов.")
    print("Успешная регистрация")
try:
    check_name_length("Илья")
    check_name_length("ДлинноеИмя")
except NameTooLongError as e:
    print(e)
```
### Результат.
![image](https://github.com/user-attachments/assets/1a063c34-dd10-4365-a478-1137cdeed66d)

## Выводы
Код демонстрирует использование пользовательского исключения для проверки длины имени и обработку этого исключения в блоке try-except

## Лабораторная работа №5
После запуска сайта вы поняли, что вам необходимо добавить логгер, для отслеживания его работы. Готовыми вариантами вы не захотели пользоваться, и поэтому решили создать очень простую пародию. Для этого создали две функции:   init  () (вызывается при создании класса декоратора в программе) и  call () (вызывается при вызове декоратора). Создайте необходимый вам декоратор. Выведите все логи в консоль.

```python
class SimpleLogger:
    def __init__(self, func):
        self.func = func
        self.init()
    def init(self):
        print("Инициализация логгера...")
    def __call__(self, *args, **kwargs):
        print("Вызов функции:", self.func.__name__)
        result = self.func(*args, **kwargs)
        print("Функция завершила выполнение")
        return result
@SimpleLogger
def test_function(a, b):
    return a + b
result = test_function(5, 3)
print("Результат:", result)
```
### Результат.
![image](https://github.com/user-attachments/assets/80b9fe7e-e6ab-4847-a891-527b0fb6f73f)

## Выводы
Код демонстрирует использование декоратора SimpleLogger для логгирования вызова функции test_function

## Самостоятельная работа №1


```python

```
### Результат.

## Выводы


## Самостоятельная работа №2


```python

```
### Результат.

## Выводы


## Самостоятельная работа №3


```python

```
### Результат.

## Выводы


## Самостоятельная работа №4


```python

```
### Результат.

## Выводы


## Самостоятельная работа №5


```python

```
### Результат.

## Выводы


## Общие выводы по теме
